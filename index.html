<!DOCTYPE html>
<html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

  <title>STEP - WebGL2 </title>

  <link rel="stylesheet" type="text/css" href="./css/jquery.dataTables.min.css" media="screen" />
  <script src="./js/jquery-2.1.4.min.js"></script>
  <script src="./js/jquery.dataTables.min.js"></script>

  <script type="text/javascript" src="./js/gl-matrix-min.js"></script>

  <script src="./js/pouchdb-5.1.0.js"></script>
  <script src="./js/pouchdb.memory.js"></script>

  <script type="text/javascript" src="../dcmio/DicomMetaDictionary.js"></script>
  <script type="text/javascript" src="../dcmio/BufferStream.js"></script>
  <script type="text/javascript" src="../dcmio/ValueRepresentation.js"></script>
  <script type="text/javascript" src="../dcmio/Tag.js"></script>
  <script type="text/javascript" src="../dcmio/DicomMessage.js"></script>
  <script type="text/javascript" src="../dcmio/normalizers.js"></script>
  <script type="text/javascript" src="../dcmio/derivations.js"></script>

  <script type="text/javascript" src="./colors.js"></script>
  <script type="text/javascript" src="./linear.js"></script>
  <script type="text/javascript" src="./fields.js"></script>
  <script type="text/javascript" src="./view.js"></script>
  <script type="text/javascript" src="./generators.js"></script>
  <script type="text/javascript" src="./renderer.js"></script>
  <script type="text/javascript" src="./growcut.js"></script>


  <link rel="stylesheet" href="./css/step.css" />
  <script type="text/javascript" src="./ui.js"></script>
  <script type="text/javascript" src="./ui.step.js"></script>

  <script type="text/javascript" src="./controls.js"></script>

  <script type="text/javascript" src="./database.js"></script>

</head>

<body>

<canvas id="renderCanvas"></canvas>

<script>
'use strict'

// once the data is downloaded
function readDICOM(arrayBuffer) {
  let dicomData = DicomMessage.readFile(arrayBuffer);
  let dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);
  return (dataset);
}

function requestInstance(url, loaded) {
  let dataRequest = new XMLHttpRequest();
  dataRequest.responseType = "arraybuffer";
  dataRequest.onload = function (event) {
    let arrayBuffer = dataRequest.response;
    loaded(arrayBuffer);
  };
  dataRequest.open("GET", url, true);
  dataRequest.send(null);
}

function requestSeries(instanceURLs) {
  let seriesDatasets = [];
  instanceURLs.forEach(function(instanceURL) {
    requestInstance(instanceURL, function(arrayBuffer) {
      let dataset = readDICOM(arrayBuffer);
      seriesDatasets.push(dataset);
      step.ui.bottomBar.progress = `Loaded ${seriesDatasets.length} of ${instanceURLs.length}`;
      if (seriesDatasets.length == instanceURLs.length) {
        let dataset = Normalizer.normalizeToDataset(seriesDatasets);
        let fields = Field.fromDataset(dataset);
        let field;
        if (fields.length > 0) {
          step.renderer.inputFields.push(...fields);
          field = fields[0];
        } else {
          field = fields;
          step.renderer.inputFields.push(field);
        }
        step.renderer.updateProgram();
        step.renderer.view.look({at: field.center, bounds: field.bounds});
        step.renderer.requestRender(step.view);
      }
    });
  });
}

function performFilter() {
  let filterField = step.renderer.inputFields[step.renderer.inputFields.length-1];
  if (!filterField || filterField.constructor.name != "ImageField") {
    alert('Need to load an image field');
    return;
  }

  let derivedImage = new DerivedImage([filterField.dataset]);
  let derivedField = Field.fromDataset(derivedImage.dataset);

  // override default calculation
  derivedField.windowCenter = filterField.windowCenter;
  derivedField.windowWidth = filterField.windowWidth;

  step.renderer.inputFields.push(derivedField);
  filterField.visible = false;
  step.renderer.updateProgram();

  step.generator = new ProgrammaticGenerator({
    gl: step.renderer.gl,
    inputFields: [filterField],
    outputFields: [derivedField],
  });

  let start = performance.now();
  let previous = start;
  let iterations = 200;
  let iteration = 0;
  let animationFrame = function() {
    step.generator.uniforms.squiggle.value = iteration;
    step.generator.generate();
    if (iteration % 10 == 0) {
      step.renderer._render();
    }
    //console.log(performance.now()-previous);
    previous = performance.now();
    iteration++;
    if (iteration < iterations) {
      requestAnimationFrame(animationFrame);
    } else {
      step.renderer.requestRender(step.view);
      console.log(performance.now()-start);
    }
  }
  requestAnimationFrame(animationFrame);

  step.renderer.requestRender(step.view);
}

function performGrowCut() {
  let backgroundField = step.renderer.inputFields[step.renderer.inputFields.length-1];
  if (!backgroundField || backgroundField.constructor.name != "ImageField") {
    alert('Need to have a background image field');
    return;
  }

  let labelFields = [];
  let strengthFields = [];
  [0,1].forEach(index=>{
    let derivedImage = new DerivedImage([backgroundField.dataset]);
    labelFields.push(Field.fromDataset(derivedImage.dataset));
    step.renderer.inputFields.push(labelFields[index]);
    labelFields[index].visible = false;
    strengthFields.push(Field.fromDataset(derivedImage.dataset));
  });
  step.renderer.updateProgram();

  step.growcut = new GrowCutGenerator({ gl: step.renderer.gl, });

  let iterations = 200;
  let iteration = 0;
  let animationFrame = function() {
    step.growcut.uniforms.iteration.value = iteration;
    let inBuffer = iteration%2;
    let outBuffer = (iteration+1)%2;
    step.growcut.inputFields = [backgroundField,
                                labelFields[inBuffer],
                                strengthFields[inBuffer]];
    step.growcut.outputFields = [labelFields[outBuffer], strengthFields[outBuffer]];
    step.growcut.updateProgram();
    step.growcut.generate();
    step.renderer._render();
    iteration++;
    if (iteration < iterations) {
      requestAnimationFrame(animationFrame);
    } else {
      step.renderer.requestRender(step.view);
    }
  }
  requestAnimationFrame(animationFrame);

  step.renderer.requestRender(step.view);
}

let uniforms = {
  pointLight: { type: '3fv', value: [100., -300., 150.] },
  gradientSize: { type: '1f', value: .01 },
  rayMaxSteps: { type: '1i', value: 10000 },
  sampleStep: { type: '1f', value: 0.1 },
};

// once document is loaded...
let step = {};
$(function () {

  //
  // renderer
  //
  let canvas = document.querySelector('#renderCanvas');
  let gl = canvas.getContext('webgl2');
  step.renderer = new RayCastRenderer({
    gl,
    canvas,
    uniforms,
    inputFields: [],
  });
  step.view = new View({
    viewBoxMax : [250, 49, -240],
    viewBoxMin : [-250, -250, -280],
    viewPoint : [0., -100., -1500.],
  });
  step.renderer._render(step.view);

  window.addEventListener('resize', resizeEvent => {
    renderCanvas.width = window.innerWidth;
    renderCanvas.height = window.innerHeight;
    if (step.renderer) {
      step.renderer.requestRender(step.view);
    }
  });
  window.dispatchEvent(new Event('resize'));


  //
  // database
  //
  step.database = new Database({url: 'http://quantome.org:5984/chronicle'});

  //
  // user interface elements
  //
  step.ui = {};
  step.ui.menubar = new stepMenubar(step, {
    database : step.database,
    requestSeries : requestSeries,
    performFilter : performFilter,
    performGrowCut : performGrowCut,
  });
  document.body.insertBefore(step.ui.menubar.dom, document.body.firstChild);

  step.ui.bottomBar = new stepBottomBar(step, {
    onSliceOffetChange : function(){},
  });
  document.body.appendChild(step.ui.bottomBar.dom);

  step.ui.sideBar = new stepSideBar(step, {
  });
  document.body.appendChild(step.ui.sideBar.dom);

  let toolSelectUI = step.ui.bottomBar.toolSelectUI;
  toolSelectUI.dom.addEventListener('change', event => {
    windowLevelControl.tool = toolSelectUI.getValue();
  });

  //
  // interactive controls
  //
  step.controls = new Controls();
  step.controls.activate({
    onWindowLevel: step.ui.sideBar.drawHistogram
  });

});

let onResize = function() {
  renderCanvas.width = window.innerWidth;
  renderCanvas.height = window.innerHeight;
}
onResize();
window.onresize = onResize;

</script>

<p>
This demo uses <a href='https://www.khronos.org/registry/webgl/specs/latest/2.0/'>WebGL2</a>.  Not all devices and browsers are supported.  As of this writing only the latest Chrome Canary or Firefox Nightly will work.  <a href='https://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation'>See this page for details.</a>
</p>

</body>
</html>
