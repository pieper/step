<!DOCTYPE html>
<html>
<head>

  <title>STEP - WebGL2 </title>

  <script src='../glimp/jquery-1.11.0.min.js'></script>

  <script type="text/javascript" src="../dcmio/DicomMetaDictionary.js"></script>
  <script type="text/javascript" src="../dcmio/BufferStream.js"></script>
  <script type="text/javascript" src="../dcmio/ValueRepresentation.js"></script>
  <script type="text/javascript" src="../dcmio/Tag.js"></script>
  <script type="text/javascript" src="../dcmio/DicomMessage.js"></script>
  <script type="text/javascript" src="../dcmio/normalizers.js"></script>

  <link rel="stylesheet" href="./css/main.css" />
  <link rel="stylesheet" href="./css/dark.css" />
  <script type="text/javascript" src="./js/ui.js"></script>
  <script type="text/javascript" src="./js/ui.step.js"></script>

</head>

<body>

<canvas id="renderCanvas"></canvas>

<script id="vertexShader" type="x-shader/x-vertex">#version 300 es
precision highp float;

in vec3 coordinate;
in vec2 textureCoordinate;

smooth out vec2 varyingTextureCoordinate;

void main(void) {
  gl_Position = vec4(coordinate,1.);
  varyingTextureCoordinate = textureCoordinate;
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">#version 300 es
precision highp float;
precision highp int;
precision highp isampler3D;

uniform highp sampler3D sourceTextureSampler;
uniform float sliceOffset;
uniform float windowCenter;
uniform float windowWidth;

in vec2 varyingTextureCoordinate;

out vec4 fragmentColor;

void main(void) {

  vec3 point = vec3(varyingTextureCoordinate,sliceOffset);
  vec4 outputColor = vec4(0.,.4, .3,1.);

  // W/L per http://dicom.nema.org/MEDICAL/Dicom/2015c/output/chtml/part03/sect_C.11.2.html#sect_C.11.2.1.2
  float pixelValue;
  pixelValue = texture(sourceTextureSampler, point).r;
  pixelValue = clamp( (pixelValue - (windowCenter-0.5)) / (windowWidth-1.) + .5, 0., 1. );

  outputColor.rgb = vec3(pixelValue);

  fragmentColor = outputColor;
}
</script>

<script>
'use strict'

// globals
let sliceOffset = 0.5;
let textureDimensions;
let renderImageCoordinatesBuffer;
let renderImageTexureCoordinatesBuffer;
let sourceTexture;
let renderCanvas = document.querySelector('#renderCanvas');
let sliceOffsetUI;

let gl = renderCanvas.getContext('webgl2');
gl.disable(gl.DEPTH_TEST); // no depth, we ray cast
gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

// the program and shaders
let glProgram = gl.createProgram();
let vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, document.getElementById("vertexShader").innerHTML);
gl.compileShader(vertexShader);
if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
  alert('Could not compile vertexShader');
  console.log(gl.getShaderInfoLog(vertexShader));
}
let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, document.getElementById("fragmentShader").innerHTML);
gl.compileShader(fragmentShader);
if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
  alert('Could not compile fragmentShader');
  console.log(gl.getShaderInfoLog(fragmentShader));
}
gl.attachShader(glProgram, vertexShader);
gl.deleteShader(vertexShader);
gl.attachShader(glProgram, fragmentShader);
gl.deleteShader(fragmentShader);
gl.linkProgram(glProgram);

let imageArray;
function setupDataset(dataset) {
  // width by height by depth (x, y z)
  textureDimensions = [dataset.Columns,dataset.Rows,dataset.NumberOfFrames];
  textureDimensions = textureDimensions.map(Number);

  if (dataset.BitsAllocated != 16) {
    alert('Can only render 16 bit data');
    return;
  }
  if (dataset.PixelRepresentation == 1) {
    imageArray = new Int16Array(dataset.PixelData);
  } else {
    imageArray = new Uint16Array(dataset.PixelData);
  }
  let imageFloat32Array = Float32Array.from(imageArray);

  //
  // set up webgl2
  //
  // buffers for the textured plane in normalized space
  renderImageCoordinatesBuffer = gl.createBuffer();
  renderImageTexureCoordinatesBuffer = gl.createBuffer();
  let renderImageVertices = [ -1., -1., 0., 1., -1., 0., -1.,  1., 0., 1.,  1., 0., ];
  gl.bindBuffer(gl.ARRAY_BUFFER, renderImageCoordinatesBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderImageVertices), gl.STATIC_DRAW);
  let renderImageTextureCoordinates = [ 0, 1,  1, 1,  0, 0,  1, 0 ];
  gl.bindBuffer(gl.ARRAY_BUFFER, renderImageTexureCoordinatesBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderImageTextureCoordinates), gl.STATIC_DRAW);

  sourceTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_3D, sourceTexture);
  gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_BASE_LEVEL, 0);
  gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAX_LEVEL, 0);
  gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
  gl.texStorage3D(gl.TEXTURE_3D, 1, gl.R32F,
       textureDimensions[0], textureDimensions[1], textureDimensions[2]);
  gl.texSubImage3D(gl.TEXTURE_3D,
        0, 0, 0, 0, // level, offsets
        textureDimensions[0], textureDimensions[1], textureDimensions[2],
        gl.RED, gl.FLOAT, imageFloat32Array);
}


// render a frame
function render() {
  gl.viewport(0, 0, renderCanvas.width, renderCanvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.useProgram(glProgram);

  // set up the textureDimensions
  gl.uniform3f(gl.getUniformLocation(glProgram, "textureDimensions"), textureDimensions[0], textureDimensions[1], textureDimensions[2]);

  // the coordinate attribute
  gl.bindBuffer(gl.ARRAY_BUFFER, renderImageCoordinatesBuffer);
  let coordinateLocation = gl.getAttribLocation(glProgram, "coordinate");
  gl.enableVertexAttribArray( coordinateLocation );
  gl.vertexAttribPointer( coordinateLocation, 3, gl.FLOAT, false, 0, 0);

  // the textureCoordinate attribute
  gl.bindBuffer(gl.ARRAY_BUFFER, renderImageTexureCoordinatesBuffer);
  let textureCoordinateLocation = gl.getAttribLocation(glProgram, "textureCoordinate");
  gl.enableVertexAttribArray( textureCoordinateLocation );
  gl.vertexAttribPointer( textureCoordinateLocation, 2, gl.FLOAT, false, 0, 0);

  let sourceTextureSampler = gl.createSampler();
  gl.bindSampler(0, sourceTextureSampler);
  gl.uniform1i(gl.getUniformLocation(glProgram, "sourceTextureSampler"), sourceTextureSampler);
  gl.uniform1f(gl.getUniformLocation(glProgram, "sliceOffset"), sliceOffset);
  gl.uniform1f(gl.getUniformLocation(glProgram, "windowCenter"), Number(dataset.WindowCenter[0]));
  gl.uniform1f(gl.getUniformLocation(glProgram, "windowWidth"), Number(dataset.WindowWidth[0]));

  // final render of calculation to display
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_3D, sourceTexture);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}


//
// user interface elements
//
function updateParameters() {
  sliceOffset = sliceOffsetUI.getValue();
  render();
}

// once the data is downloaded
let dicomData;
let dataset;
function readDICOM(arrayBuffer) {
  dicomData = DicomMessage.readFile(arrayBuffer);
  dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);
  dataset = Normalizer.normalizeToDataset([dataset]);
  setupDataset(dataset);
  render();
}

function requestInstance(url) {
  let dataRequest = new XMLHttpRequest();
  dataRequest.responseType = "arraybuffer";
  dataRequest.onload = function (event) {
    readDICOM(dataRequest.response);
  };
  dataRequest.onprogress = function () {
    console.log('LOADING', dataRequest.status);
  };
  dataRequest.open("GET", url, true);
  dataRequest.send(null);
}

// once document is loaded...
$(function () {

  let step = new STEP();

  let menubar = new stepMenubar(step);
  document.body.insertBefore(menubar.dom, document.body.firstChild);

  sliceOffsetUI = new UI.Number();
  sliceOffsetUI.value = .5;
  sliceOffsetUI.min = 0;
  sliceOffsetUI.max = 1;
  sliceOffsetUI.precision = 2;
  sliceOffsetUI.step = .25;
  sliceOffsetUI.unit = "offset";
  document.body.appendChild(sliceOffsetUI.dom);
  sliceOffsetUI.onChange(updateParameters);

  let instanceURL;
  instanceURL = 'http://quantome.org:5984/chronicle/1.3.6.1.4.1.14519.5.2.1.4334.1501.121218257574955556754163036146/object.dcm'
  instanceURL = 'http://quantome.org:5984/chronicle/1.3.6.1.4.1.32722.99.99.238384565775432409889098605483402280666/object.dcm';
  instanceURL = 'https://s3.amazonaws.com/IsomicsPublic/4-T2-multiframe-IPP_sorted_UID_fixed.dcm';
  instanceURL = 'http://quantome.org:5984/chronicle/1.3.6.1.4.1.14519.5.2.1.3671.7001.175674587621970014199598735325/object.dcm';
  requestInstance(instanceURL);
});

let onResize = function() {
  renderCanvas.width = window.innerWidth;
  renderCanvas.height = window.innerHeight;
}
onResize();
window.onresize = onResize;

</script>

<p>
<br>
Check out <a href='https://github.com/pieper/sites/tree/gh-pages/step.html'>the source code</a>.
</p>

<p>
This demo uses WebGL2.  Not all devices and browsers are supported.  As of this writing only the latest Chrome Canary or Firefox Nightly will work.
</p>

</body>
</html>
